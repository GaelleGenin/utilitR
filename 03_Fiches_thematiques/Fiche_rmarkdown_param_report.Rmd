# Produire des rapports automatisés avec `R Markdown` {#rapports-auto}

## Tâches concernées et recommandations

L'utilisateur souhaite réaliser des rapports automatisés, reproductibles et faciles à actualiser en cas de modification des données. Il souhaite également produire de nombreux rapports en modifiant, en fonction de ses besoins, certains paramètres.

::: {.recommandation}
Il est recommandé d'utiliser `R Markdown` pour produire des rapports paramétrés Si vous ne connaissez pas `R Markdown`, il est indispensable de lire au préalable la [fiche `R Markdown`](#R Markdown).
:::

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      fig.pos='H',
                      fig.align = "center",
                      warning=FALSE,
                      message=FALSE)
```

## Les rapports automatisés

### Introduction

Un rapport automatisé est un document qui contient du texte et des informations (graphiques, tableaux...) produites en exécutant un code, appelé code source. Un rapport automatisé peut prendre plusieurs formes :

+ une page internet (un fichier html) ;
+ un document texte (`Word`, `writer`, LaTeX) ;
+ une présentation (_slides_) ;
+ une carte.

Les rapports automatisés présentent deux grands avantages. Premièrement, ils sont reproductibles, car le code source contient toutes les instructions nécessaires à la production des informations contenues dans le rapport. Deuxièmement, ils sont faciles à actualiser en cas de modification des données.

Dans le cas de `R Markdown`, le code source est un fichier texte portant l'extension `.Rmd`. Le document final (ou *output*) est produit après une étape de compilation, en cliquant sur le bouton `knit` de `RStudio`. Le fichier `R Markdown` combine généralement des instructions de traitements des données, mais aussi du texte, des images, des cartes... Les instructions de traitement de données sont généralement rédigées en `R`, mais il est tout à fait possible d'utiliser `R Markdown` avec d'autres langages (par exemple `python`). L'utilisatio de  `R Markdown` est détaillée dans la [fiche `R Markdown`](#R Markdown).

### Quelques bonnes pratiques

Cette section détaille les bonnes pratiques à adopter pour réaliser des rapports automatisés.

### Remplir l'en-tête

Le code source d'un rapport automatisé commence toujours par un en-tête `YAML` qui doit contenir au minimum un titre, une date et un format de sortie. Voici un exemple d'en-tête :

~~~
---
title: "Titre du rapport"
date: '`r format(Sys.time(), "%d %B %Y")`'
output: pdf_document
author: "Anne Onyme"
description: "Une description vraiment utile"
---
~~~

L'en-tête permet de personnaliser finement le document de sortie, par exemple en ajoutant une table des matières ou une bibliographie. Il existe un nombre considérable d'options, dont certaines sont spécifiques à un format de sortie (pdf, html, ...). La liste des options est détaillée sur le site de la documentation officielle de `R Markdown` et sur l’antisèche et le guide de référence, accessibles depuis RStudio via le menu `Help` puis `Cheatsheets.`

::: {.conseil}
Si vous souhaitez construire un rapport automatisé que vous utiliserez régulièrement, il est vivement conseillé de prendre le temps de définir un en-tête qui corresponde précisément à ce que vous voulez produire.
:::


### Configurer le fonctionnement de `knitr`

Dans un deuxième temps, il est souhaitable de configurer le comportement par défaut de `knitr`. La [fiche `R Markdown`](#R Markdown) détaille les principales options. Dans le cas des rapports automatisés, la configuration de `knitr` doit porter au minimum sur les deux points suivants :

* la position et taille des figures ;
* l'affichage ou non des instructions `R` dans le fichier de sortie.

La méthode la plus simple pour configurer `knitr` consiste à inclure un *chunk* de configuration au début du fichier `R Markdown` (juste après l'en-tête). Ce *chunk* de configuration utilise la fonction `knitr::opts_chunk$set()` pour définir les options par défaut applicables à tous les _chunks_ du code source. La fonction `opts_chunk$set` permet de définir de nombreux paramètres, dont la liste complète est disponible sur https://yihui.org/knitr/options. Voici un exemple de _chunk_ de configuration.

~~~
```{r configuration, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning=FALSE,
                      message=FALSE,
                      error = TRUE,
                      fig.align = "center",
                      fig.width = '75%')
```
~~~

Dans cet exemple, il est demandé à `R Markdown` de ne pas inclure les instructions `R` dans le document de sortie (`echo = FALSE`). Les *warnings* et les messages d'informations n'apparaîtront pas non plus dans le fichier de sortie. En revanche, les erreurs apparaîtront (`error = TRUE`). Les figures sont centrées (`fig.align = "center"`) et ont une largeur de 75% de la largeur du texte (`fig.width = '75%'`).

::: {.conseil}
Une attention particulière doit être portée à l'utilisation de l'option `cache`. L'option `cache = TRUE` permet de signaler à `R Markdown` de ne pas ré-exécuter du code n'ayant pas été modifié depuis la dernière compilation. Ceci peut faire gagner beaucoup de temps, notamment pour les *chunks* d'importation de données volumineuses, mais peut conduire à des comportements non souhaités, notamment lorsque les données que vous utilisez dans votre rapport ont été actualisées. Si vous utilisez l'option `cache = TRUE`, et si aucun élément du code source n'a été modifié, alors les données ne seront pas réimportées lorsque vous recompilerez le rapport.
:::

### Charger les _packages_

Enfin, il est recommandé d'intégrer au début de votre code source (par exemple juste après la configuration des options de `knitr`) un *chunk* de chargement des _packages_ utilisés dans le rapport. A titre d'exemple, le *chunk* pourrait ressembler à ceci :

~~~
```{r packages}
library(doremifasolData)
library(data.table)
library(ggplot2)
```
~~~

### Charger les données

Encore une fois, il est conseillé de nommer ces *chunks* de façon non ambigüe, afin de repérer rapidement d'éventuelles erreurs lors de la compilation.


## La production de rapports "de masse" : les rapports paramétrés





Les rapports paramétrés sont une forme particulière de rapports automatisés. Ils présentent donc les mêmes avantages que les rapports automatisés (quasi reproductibles, simple à actualiser), mais permettent d'aller un peu plus loin en terme de fonctionnalités. Il est ainsi possible de générer différents rapports utilisant la même base d'instruction, mais en distinguant les traitements selon un ou plusieurs paramètres à fixer dans l'en-tête `YAML`.

Un court exemple est parfois mieux qu'un long discours, nous allons voir ci-dessous un modèle de rapport "générique" (un *template*), qui peut se décliner selon :

+ différents territoires ;
+ différentes périodicités ;
+ différents code d'une nomenclature...

Bref, selon différents **paramètres**.

Prenons l'exemple très simple d'un utilisateur qui doit générer une table d'effectif de chaque département français.

Pour cela, il peut être tenté de multiplier les fichiers `R Markdown` (`fichierAin.Rmd`, `fichierAisne.Rmd`...).

Cette approche, si elle se justifie lorsque le nombre de document à produire est réduit, voit ses limites lorsqu'il s'agit de réaliser plusieurs dizaines de rapports. C'est à ce moment que le système de rapports paramétrés prend tout son sens.

L'utilisateur a eu vent de la fonctionnalité de rapports paramétrés. Il doit alors réaliser un *template* de document qui s'appliquera de la même façon pour chaque département.

## Un exemple de *template*

Voici un exemple (appelons le `rapportParametre.Rmd`) permettant de répondre au besoin de notre utilisateur :

~~~

---
title: "Mon rapport"
date: "`r Sys.Date()`"
output: pdf_document
params:
  codeDpt: "01"
---

```{r doremisfasol, eval=FALSE, echo=TRUE}
library("doremifasolData")
```

```{r importData, eval=FALSE, echo=TRUE}
cogCom2019 <- doremifasolData::cog_com_2019
```

```{r selectData, eval=FALSE, echo=TRUE}
monDpt <- cogCom2019[cogCom2019$dep %in% params$codeDpt, ]
```

```{r tableData, eval=FALSE, echo=TRUE}
table(monDpt$dep)
```
~~~

La compilation de ce fichier, au travers de la commande `R Markdown::render(input = rapportParametre.Rmd.Rmd)` génèrera le document suivant :

~~~
 01
393
~~~

La fonction `render` permet de transformer un format de fichier (ici `rapportParametre.Rmd`) en un autre, défini dans l'en-tête `YAML`. On remarque que la fonction produit une table d'effectif des communes de l'Ain (département 01) car cette valeur a été définie par défaut dans l'en-tête. Si l'utilisateur souhaite produire le même type de document pour un autre département, il devra **passer explicitement le paramètre `params = list(codeDpt = "XX")`** à la fonction `render`.

```{r tableDpt02, eval=FALSE, echo=TRUE}
R Markdown::render(input = rapportParametre.Rmd, params = list(codeDpt = "02"))
```

Dans cet exemple, l'*output* ressemblera à ceci :

~~~
 02
800
~~~

Il y a donc 800 communes dans l'Aisne.

::: {.conseil}
Il est possible de créer une fonction pour simplifier la génération de rapports paramétrés.
:::

Afin d'illuster ce conseil, voici un exemple de fonction créée *ad hoc* par l'utilisateur désireux de simplifier la production d'un rapport paramétré :

~~~
monRapport <- function(codeDpt) {
	R Markdown::render(input = "rapportParametre.Rmd",
										params = list(codeDpt = codeDpt),
										envir = new.env(),
										output_file = paste0("Rapport_", codeDpt, ".pdf")
	)
}
~~~

Une fois la fonction établie, les rapports se réaliseront *via* la commande :

~~~
monRapport(codeDpt = "02")
~~~

Enfin, cette fonction peut également s'utiliser dans une boucle, au sein d'un autre document `R Markdown` :

~~~
for(i in maListeDeDpt) {
	monRapport(i)
}
~~~

Le modèle de *rapportParametre.Rmd* présenté dans cette fiche est disponible en téléchargement en cliquant sur le lien suivant (insérer lien vers fichier).

# PESP

https://bookdown.org/yihui/R Markdown/parameterized-reports.html
